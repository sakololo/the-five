---
description: バグの根本原因を正確に特定するための分析プロトコル
---

# バグ分析ワークフロー

> **教訓**: 2026-02-09の検索バグ分析で3回の訂正を経て確定したプロセス

## Phase 1: データ収集（コードを読む前に）

### 1.1 失敗ケースの特定
```powershell
# 問題が再現するケースを記録
Invoke-RestMethod "http://localhost:3000/api/[endpoint]?q=[問題のクエリ]"
```
- [ ] 具体的な入力を記録
- [ ] 期待される出力を記録
- [ ] 実際の出力を記録

### 1.2 成功ケースの特定（必須！）
```powershell
# 類似だが成功するケースを見つける
Invoke-RestMethod "http://localhost:3000/api/[endpoint]?q=[成功するクエリ]"
```
- [ ] 成功ケースと失敗ケースの**差異**を特定

## Phase 2: データフロー追跡

### 2.1 コードにデバッグログを追加
```typescript
// 各変換ステップで値をログ出力
console.log(`[DEBUG] Step X: ${変数名}`);
```

### 2.2 条件分岐の確認
- [ ] if/else による分岐を特定
- [ ] 成功ケースと失敗ケースで**どの分岐を通るか**確認
- [ ] 分岐後の処理の違いを確認

## Phase 3: 仮説検証

### 3.1 仮説を立てる
```markdown
仮説: [具体的な原因の推測]
検証方法: [どうやって確認するか]
```

### 3.2 仮説を検証
- [ ] デバッグ出力で仮説を確認
- [ ] **成功ケースでも同じ分析を実施**（比較のため）

### 3.3 仮説が間違っていた場合
> [!WARNING]
> 最初の仮説が正しいとは限らない。今回は3回訂正した。

- [ ] 新しい仮説を立てる
- [ ] Phase 2に戻る

## Phase 4: 根本原因の確定

- [ ] 成功ケースと失敗ケースの差異で原因を説明できる
- [ ] コードの該当箇所を特定
- [ ] 修正案が問題を解決することを論理的に説明できる

## Phase 5: 修正前の最終確認

- [ ] 修正案が副作用を起こさないか確認
- [ ] 既存のテストケースへの影響を確認
- [ ] デバッグログを削除

---

## アンチパターン（やってはいけないこと）

| ❌ やってはいけない | ✅ 代わりにやるべき |
|--------------------|---------------------|
| コードを読んで即断する | データで検証してから結論 |
| 失敗ケースだけ調べる | 成功ケースと比較する |
| 最初の仮説を信じる | 複数の仮説を検証する |
| 条件分岐を無視する | 全てのコードパスを追う |

---

## 今回の事例

```
分析1: 「Relevance Guardが厳格」 → ❌ 表層的
分析2: 「scorer.ts L77のバグ」   → ❌ 不完全
分析3: 「normalizer.ts L205」    → ✅ 確定

教訓: 成功ケース（鬼滅の刃）と失敗ケース（青の祓魔師）を
      早期に比較していれば、1回で正解にたどり着けた
```
